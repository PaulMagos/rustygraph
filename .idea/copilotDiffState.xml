<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.gitignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.gitignore" />
              <option name="originalContent" value="/target&#10;" />
              <option name="updatedContent" value="# Rust build artifacts&#10;/target&#10;**/*.rs.bk&#10;*.pdb&#10;&#10;# Cargo lock file (optional for libraries)&#10;# Cargo.lock&#10;&#10;# IDE files&#10;.idea/&#10;.vscode/&#10;*.swp&#10;*.swo&#10;*~&#10;.DS_Store&#10;&#10;# Documentation build&#10;/target/doc&#10;&#10;# Benchmark results&#10;/target/criterion&#10;&#10;# Test coverage&#10;/target/coverage&#10;*.profraw&#10;*.profdata&#10;&#10;# Backup files&#10;*.bak&#10;*.orig&#10;&#10;# Local development&#10;PROGRESS.md&#10;notes.md&#10;scratch.rs&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/lib.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/lib.rs" />
              <option name="originalContent" value="//! # RustyGraph&#10;//!&#10;//! `rustygraph` is a high-performance Rust library for visibility graph computation from time series data.&#10;//!&#10;//! ## Features&#10;//!&#10;//! - **Natural Visibility Graphs**: O(n) implementation using monotonic stack optimization&#10;//! - **Horizontal Visibility Graphs**: Fast O(n) average case algorithm&#10;//! - **Node Feature Computation**: Extensible system for computing node features (basis expansion/data augmentation)&#10;//! - **Missing Data Handling**: Configurable strategies for imputation&#10;//! - **Custom Functions**: Support for user-defined features and imputation strategies&#10;//!&#10;//! ## Quick Start&#10;//!&#10;//! ```rust&#10;//! use rustygraph::*;&#10;//!&#10;//! # fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {&#10;//! // Create a time series&#10;//! let series = TimeSeries::from_raw(vec![1.0, 3.0, 2.0, 4.0, 1.0]);&#10;//!&#10;//! // Build a natural visibility graph&#10;//! let graph = VisibilityGraph::from_series(&amp;series)&#10;//!     .natural_visibility()?;&#10;//!&#10;//! // Access the results&#10;//! println!(&quot;Number of edges: {}&quot;, graph.edges().len());&#10;//! println!(&quot;Degree sequence: {:?}&quot;, graph.degree_sequence());&#10;//! # Ok(())&#10;//! # }&#10;//! ```&#10;//!&#10;//! ## Advanced Usage with Features&#10;//!&#10;//! ```rust&#10;//! use rustygraph::*;&#10;//!&#10;//! # fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {&#10;//! // Create time series with missing data&#10;//! let series = TimeSeries::new(&#10;//!     vec![0.0, 1.0, 2.0, 3.0, 4.0],&#10;//!     vec![Some(1.0), None, Some(3.0), Some(2.0), Some(4.0)]&#10;//! )?;&#10;//!&#10;//! // Handle missing data&#10;//! let cleaned = series.handle_missing(&#10;//!     MissingDataStrategy::LinearInterpolation&#10;//!         .with_fallback(MissingDataStrategy::ForwardFill)&#10;//! )?;&#10;//!&#10;//! // Create graph with node features&#10;//! let graph = VisibilityGraph::from_series(&amp;cleaned)&#10;//!     .with_features(&#10;//!         FeatureSet::new()&#10;//!             .add_builtin(BuiltinFeature::DeltaForward)&#10;//!             .add_builtin(BuiltinFeature::LocalSlope)&#10;//!             .add_function(&quot;squared&quot;, |series, idx| {&#10;//!                 series[idx].map(|v| v * v)&#10;//!             })&#10;//!     )&#10;//!     .horizontal_visibility()?;&#10;//!&#10;//! // Inspect node features&#10;//! for i in 0..graph.node_count {&#10;//!     if let Some(features) = graph.node_features(i) {&#10;//!         println!(&quot;Node {}: {:?}&quot;, i, features);&#10;//!     }&#10;//! }&#10;//! # Ok(())&#10;//! # }&#10;//! ```&#10;//!&#10;//! ## Architecture&#10;//!&#10;//! The library is organized into several modules:&#10;//!&#10;//! - [`time_series`]: Time series data structures and preprocessing&#10;//! - [`visibility_graph`]: Visibility graph construction and representation&#10;//! - [`features`]: Node feature computation framework&#10;//! - [`features::missing_data`]: Missing data handling strategies&#10;//! - [`algorithms`]: Core visibility graph algorithms&#10;//!&#10;//! ## Performance&#10;//!&#10;//! - **Natural visibility**: O(n) per node using monotonic stack optimization&#10;//! - **Horizontal visibility**: O(n) average case&#10;//! - **Memory efficient**: Adjacency list representation for sparse graphs&#10;//! - **Type generic**: Works with both `f32` and `f64`&#10;&#10;#![warn(missing_docs)]&#10;#![warn(rustdoc::broken_intra_doc_links)]&#10;&#10;pub mod time_series;&#10;pub mod visibility_graph;&#10;pub mod features;&#10;pub mod algorithms;&#10;&#10;// Re-export main types for convenience&#10;pub use time_series::{TimeSeries, TimeSeriesError};&#10;pub use visibility_graph::{VisibilityGraph, VisibilityGraphBuilder, GraphError};&#10;pub use features::{Feature, FeatureSet, BuiltinFeature};&#10;pub use features::missing_data::{MissingDataHandler, MissingDataStrategy, ImputationError};&#10;" />
              <option name="updatedContent" value="//! # RustyGraph&#10;//!&#10;//! `rustygraph` is a high-performance Rust library for visibility graph computation from time series data.&#10;//!&#10;//! ## Features&#10;//!&#10;//! - **Natural Visibility Graphs**: O(n) implementation using monotonic stack optimization&#10;//! - **Horizontal Visibility Graphs**: Fast O(n) average case algorithm&#10;//! - **Node Feature Computation**: Extensible system for computing node features (basis expansion/data augmentation)&#10;//! - **Missing Data Handling**: Configurable strategies for imputation&#10;//! - **Custom Functions**: Support for user-defined features and imputation strategies&#10;//!&#10;//! ## Quick Start&#10;//!&#10;//! ```rust&#10;//! use rustygraph::*;&#10;//!&#10;//! # fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {&#10;//! // Create a time series&#10;//! let series = TimeSeries::from_raw(vec![1.0, 3.0, 2.0, 4.0, 1.0]);&#10;//!&#10;//! // Build a natural visibility graph&#10;//! let graph = VisibilityGraph::from_series(&amp;series)&#10;//!     .natural_visibility()?;&#10;//!&#10;//! // Access the results&#10;//! println!(&quot;Number of edges: {}&quot;, graph.edges().len());&#10;//! println!(&quot;Degree sequence: {:?}&quot;, graph.degree_sequence());&#10;//! # Ok(())&#10;//! # }&#10;//! ```&#10;//!&#10;//! ## Advanced Usage with Features&#10;//!&#10;//! ```rust&#10;//! use rustygraph::*;&#10;//!&#10;//! # fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {&#10;//! // Create time series with missing data&#10;//! let series = TimeSeries::new(&#10;//!     vec![0.0, 1.0, 2.0, 3.0, 4.0],&#10;//!     vec![Some(1.0), None, Some(3.0), Some(2.0), Some(4.0)]&#10;//! )?;&#10;//!&#10;//! // Handle missing data&#10;//! let cleaned = series.handle_missing(&#10;//!     MissingDataStrategy::LinearInterpolation&#10;//!         .with_fallback(MissingDataStrategy::ForwardFill)&#10;//! )?;&#10;//!&#10;//! // Create graph with node features&#10;//! let graph = VisibilityGraph::from_series(&amp;cleaned)&#10;//!     .with_features(&#10;//!         FeatureSet::new()&#10;//!             .add_builtin(BuiltinFeature::DeltaForward)&#10;//!             .add_builtin(BuiltinFeature::LocalSlope)&#10;//!             .add_function(&quot;squared&quot;, |series, idx| {&#10;//!                 series[idx].map(|v| v * v)&#10;//!             })&#10;//!     )&#10;//!     .horizontal_visibility()?;&#10;//!&#10;//! // Inspect node features&#10;//! for i in 0..graph.node_count {&#10;//!     if let Some(features) = graph.node_features(i) {&#10;//!         println!(&quot;Node {}: {:?}&quot;, i, features);&#10;//!     }&#10;//! }&#10;//! # Ok(())&#10;//! # }&#10;//! ```&#10;//!&#10;//! ## Architecture&#10;//!&#10;//! The library is organized into several modules:&#10;//!&#10;//! - [`time_series`]: Time series data structures and preprocessing&#10;//! - [`visibility_graph`]: Visibility graph construction and representation&#10;//! - [`features`]: Node feature computation framework&#10;//! - [`features::missing_data`]: Missing data handling strategies&#10;//! - [`algorithms`]: Core visibility graph algorithms&#10;//!&#10;//! ## Performance&#10;//!&#10;//! - **Natural visibility**: O(n) per node using monotonic stack optimization&#10;//! - **Horizontal visibility**: O(n) average case&#10;//! - **Memory efficient**: Adjacency list representation for sparse graphs&#10;//! - **Type generic**: Works with both `f32` and `f64`&#10;&#10;#![warn(missing_docs)]&#10;#![warn(rustdoc::broken_intra_doc_links)]&#10;&#10;pub mod time_series;&#10;pub mod visibility_graph;&#10;pub mod features;&#10;pub mod algorithms;&#10;&#10;// Re-export main types for convenience&#10;pub use time_series::{TimeSeries, TimeSeriesError};&#10;pub use visibility_graph::{VisibilityGraph, VisibilityGraphBuilder, GraphError};&#10;pub use features::{Feature, FeatureSet, BuiltinFeature};&#10;pub use features::missing_data::{MissingDataHandler, MissingDataStrategy, ImputationError};&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/time_series.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/time_series.rs" />
              <option name="originalContent" value="//! Time series data structures and operations.&#10;//!&#10;//! This module provides the [`TimeSeries`] type for representing time series data,&#10;//! with support for missing values and preprocessing operations.&#10;//!&#10;//! # Examples&#10;//!&#10;//! ```rust&#10;//! use rustygraph::time_series::TimeSeries;&#10;//!&#10;//! // Create from raw values (auto-generates timestamps)&#10;//! let series = TimeSeries::from_raw(vec![1.0, 2.0, 3.0, 4.0]);&#10;//!&#10;//! // Create with explicit timestamps&#10;//! let series = TimeSeries::new(&#10;//!     vec![0.0, 0.5, 1.0, 1.5],&#10;//!     vec![Some(1.0), Some(2.0), Some(3.0), Some(4.0)]&#10;//! ).unwrap();&#10;//! ```&#10;&#10;use std::fmt;&#10;&#10;/// Time series data container with optional missing value support.&#10;///&#10;/// The `TimeSeries` struct holds temporal data points with associated timestamps.&#10;/// It supports missing values through the `Option&lt;T&gt;` wrapper, allowing for&#10;/// flexible data preprocessing and imputation strategies.&#10;///&#10;/// # Type Parameters&#10;///&#10;/// - `T`: Numeric type that implements `Float` trait (typically `f32` or `f64`)&#10;///&#10;/// # Examples&#10;///&#10;/// ## Creating a time series&#10;///&#10;/// ```rust&#10;/// use rustygraph::TimeSeries;&#10;///&#10;/// // From raw values with auto-generated timestamps&#10;/// let series = TimeSeries::from_raw(vec![1.0, 3.0, 2.0, 4.0, 1.0]);&#10;/// assert_eq!(series.len(), 5);&#10;///&#10;/// // With explicit timestamps and missing values&#10;/// let series = TimeSeries::new(&#10;///     vec![0.0, 1.0, 2.0, 3.0],&#10;///     vec![Some(1.0), None, Some(3.0), Some(2.0)]&#10;/// ).unwrap();&#10;/// ```&#10;///&#10;/// ## Handling missing data&#10;///&#10;/// ```rust&#10;/// use rustygraph::{TimeSeries, MissingDataStrategy};&#10;///&#10;/// let series = TimeSeries::new(&#10;///     vec![0.0, 1.0, 2.0],&#10;///     vec![Some(1.0), None, Some(3.0)]&#10;/// ).unwrap();&#10;///&#10;/// let cleaned = series.handle_missing(MissingDataStrategy::LinearInterpolation).unwrap();&#10;/// ```&#10;#[derive(Debug, Clone)]&#10;pub struct TimeSeries&lt;T&gt; {&#10;    /// Timestamps for each data point&#10;    pub timestamps: Vec&lt;f64&gt;,&#10;    /// Data values (None indicates missing data)&#10;    pub values: Vec&lt;Option&lt;T&gt;&gt;,&#10;}&#10;&#10;impl&lt;T&gt; TimeSeries&lt;T&gt; {&#10;    /// Creates a time series from raw values with auto-generated timestamps.&#10;    ///&#10;    /// Timestamps are generated as sequential integers starting from 0.&#10;    ///&#10;    /// # Arguments&#10;    ///&#10;    /// - `values`: Vector of data points&#10;    ///&#10;    /// # Returns&#10;    ///&#10;    /// A new `TimeSeries` with sequential integer timestamps (0, 1, 2, ...)&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```rust&#10;    /// use rustygraph::TimeSeries;&#10;    ///&#10;    /// let series = TimeSeries::from_raw(vec![1.0, 2.0, 3.0]);&#10;    /// assert_eq!(series.len(), 3);&#10;    /// assert_eq!(series.timestamps, vec![0.0, 1.0, 2.0]);&#10;    /// ```&#10;    pub fn from_raw(values: Vec&lt;T&gt;) -&gt; Self {&#10;        let n = values.len();&#10;        let timestamps: Vec&lt;f64&gt; = (0..n).map(|i| i as f64).collect();&#10;        let values: Vec&lt;Option&lt;T&gt;&gt; = values.into_iter().map(Some).collect();&#10;        &#10;        TimeSeries { timestamps, values }&#10;    }&#10;&#10;    /// Creates a time series with explicit timestamps.&#10;    ///&#10;    /// # Arguments&#10;    ///&#10;    /// - `timestamps`: Time points for each value&#10;    /// - `values`: Data values (Some(v) for present, None for missing)&#10;    ///&#10;    /// # Errors&#10;    ///&#10;    /// Returns [`TimeSeriesError::LengthMismatch`] if timestamps and values have different lengths.&#10;    /// Returns [`TimeSeriesError::EmptyData`] if both vectors are empty.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```rust&#10;    /// use rustygraph::TimeSeries;&#10;    ///&#10;    /// let series = TimeSeries::new(&#10;    ///     vec![0.0, 1.0, 2.0],&#10;    ///     vec![Some(1.0), None, Some(3.0)]&#10;    /// ).unwrap();&#10;    /// ```&#10;    pub fn new(timestamps: Vec&lt;f64&gt;, values: Vec&lt;Option&lt;T&gt;&gt;) -&gt; Result&lt;Self, TimeSeriesError&gt; {&#10;        if timestamps.len() != values.len() {&#10;            return Err(TimeSeriesError::LengthMismatch {&#10;                timestamps: timestamps.len(),&#10;                values: values.len(),&#10;            });&#10;        }&#10;        &#10;        if timestamps.is_empty() {&#10;            return Err(TimeSeriesError::EmptyData);&#10;        }&#10;        &#10;        Ok(TimeSeries { timestamps, values })&#10;    }&#10;&#10;    /// Returns the length of the time series.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```rust&#10;    /// use rustygraph::TimeSeries;&#10;    ///&#10;    /// let series = TimeSeries::from_raw(vec![1.0, 2.0, 3.0]);&#10;    /// assert_eq!(series.len(), 3);&#10;    /// ```&#10;    pub fn len(&amp;self) -&gt; usize {&#10;        self.values.len()&#10;    }&#10;&#10;    /// Returns true if the time series contains no data points.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```rust&#10;    /// use rustygraph::TimeSeries;&#10;    ///&#10;    /// let series = TimeSeries::from_raw(vec![1.0]);&#10;    /// assert!(!series.is_empty());&#10;    /// ```&#10;    pub fn is_empty(&amp;self) -&gt; bool {&#10;        self.values.is_empty()&#10;    }&#10;}&#10;&#10;// Placeholder for missing data handling - will be implemented in features module&#10;impl&lt;T&gt; TimeSeries&lt;T&gt; {&#10;    /// Handles missing data using the specified strategy.&#10;    ///&#10;    /// This method creates a new time series with imputed values based on the&#10;    /// chosen strategy. The original series is not modified.&#10;    ///&#10;    /// # Arguments&#10;    ///&#10;    /// - `strategy`: The imputation strategy to apply&#10;    ///&#10;    /// # Returns&#10;    ///&#10;    /// A new `TimeSeries` with imputed values&#10;    ///&#10;    /// # Errors&#10;    ///&#10;    /// Returns an error if imputation fails (e.g., insufficient data for the strategy)&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```rust&#10;    /// use rustygraph::{TimeSeries, MissingDataStrategy};&#10;    ///&#10;    /// let series = TimeSeries::new(&#10;    ///     vec![0.0, 1.0, 2.0],&#10;    ///     vec![Some(1.0), None, Some(3.0)]&#10;    /// ).unwrap();&#10;    ///&#10;    /// let cleaned = series.handle_missing(&#10;    ///     MissingDataStrategy::LinearInterpolation&#10;    /// ).unwrap();&#10;    /// ```&#10;    pub fn handle_missing(&amp;self, _strategy: crate::features::missing_data::MissingDataStrategy) &#10;        -&gt; Result&lt;Self, crate::features::missing_data::ImputationError&gt; &#10;    where&#10;        T: Clone,&#10;    {&#10;        // Implementation will be provided&#10;        todo!(&quot;Missing data handling implementation&quot;)&#10;    }&#10;}&#10;&#10;/// Errors that can occur during time series operations.&#10;#[derive(Debug, Clone, PartialEq)]&#10;pub enum TimeSeriesError {&#10;    /// Timestamps and values have different lengths&#10;    LengthMismatch {&#10;        /// Number of timestamps&#10;        timestamps: usize,&#10;        /// Number of values&#10;        values: usize,&#10;    },&#10;    /// Empty time series&#10;    EmptyData,&#10;    /// Invalid timestamp order (not monotonically increasing)&#10;    NonMonotonicTimestamps,&#10;}&#10;&#10;impl fmt::Display for TimeSeriesError {&#10;    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        match self {&#10;            TimeSeriesError::LengthMismatch { timestamps, values } =&gt; {&#10;                write!(f, &quot;Length mismatch: {} timestamps but {} values&quot;, timestamps, values)&#10;            }&#10;            TimeSeriesError::EmptyData =&gt; write!(f, &quot;Time series is empty&quot;),&#10;            TimeSeriesError::NonMonotonicTimestamps =&gt; {&#10;                write!(f, &quot;Timestamps must be monotonically increasing&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;impl std::error::Error for TimeSeriesError {}&#10;" />
              <option name="updatedContent" value="//! Time series data structures and operations.&#10;//!&#10;//! This module provides the [`TimeSeries`] type for representing time series data,&#10;//! with support for missing values and preprocessing operations.&#10;//!&#10;//! # Examples&#10;//!&#10;//! ```rust&#10;//! use rustygraph::time_series::TimeSeries;&#10;//!&#10;//! // Create from raw values (auto-generates timestamps)&#10;//! let series = TimeSeries::from_raw(vec![1.0, 2.0, 3.0, 4.0]);&#10;//!&#10;//! // Create with explicit timestamps&#10;//! let series = TimeSeries::new(&#10;//!     vec![0.0, 0.5, 1.0, 1.5],&#10;//!     vec![Some(1.0), Some(2.0), Some(3.0), Some(4.0)]&#10;//! ).unwrap();&#10;//! ```&#10;&#10;use std::fmt;&#10;&#10;/// Time series data container with optional missing value support.&#10;///&#10;/// The `TimeSeries` struct holds temporal data points with associated timestamps.&#10;/// It supports missing values through the `Option&lt;T&gt;` wrapper, allowing for&#10;/// flexible data preprocessing and imputation strategies.&#10;///&#10;/// # Type Parameters&#10;///&#10;/// - `T`: Numeric type that implements `Float` trait (typically `f32` or `f64`)&#10;///&#10;/// # Examples&#10;///&#10;/// ## Creating a time series&#10;///&#10;/// ```rust&#10;/// use rustygraph::TimeSeries;&#10;///&#10;/// // From raw values with auto-generated timestamps&#10;/// let series = TimeSeries::from_raw(vec![1.0, 3.0, 2.0, 4.0, 1.0]);&#10;/// assert_eq!(series.len(), 5);&#10;///&#10;/// // With explicit timestamps and missing values&#10;/// let series = TimeSeries::new(&#10;///     vec![0.0, 1.0, 2.0, 3.0],&#10;///     vec![Some(1.0), None, Some(3.0), Some(2.0)]&#10;/// ).unwrap();&#10;/// ```&#10;///&#10;/// ## Handling missing data&#10;///&#10;/// ```rust&#10;/// use rustygraph::{TimeSeries, MissingDataStrategy};&#10;///&#10;/// let series = TimeSeries::new(&#10;///     vec![0.0, 1.0, 2.0],&#10;///     vec![Some(1.0), None, Some(3.0)]&#10;/// ).unwrap();&#10;///&#10;/// let cleaned = series.handle_missing(MissingDataStrategy::LinearInterpolation).unwrap();&#10;/// ```&#10;#[derive(Debug, Clone)]&#10;pub struct TimeSeries&lt;T&gt; {&#10;    /// Timestamps for each data point&#10;    pub timestamps: Vec&lt;f64&gt;,&#10;    /// Data values (None indicates missing data)&#10;    pub values: Vec&lt;Option&lt;T&gt;&gt;,&#10;}&#10;&#10;impl&lt;T&gt; TimeSeries&lt;T&gt; {&#10;    /// Creates a time series from raw values with auto-generated timestamps.&#10;    ///&#10;    /// Timestamps are generated as sequential integers starting from 0.&#10;    ///&#10;    /// # Arguments&#10;    ///&#10;    /// - `values`: Vector of data points&#10;    ///&#10;    /// # Returns&#10;    ///&#10;    /// A new `TimeSeries` with sequential integer timestamps (0, 1, 2, ...)&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```rust&#10;    /// use rustygraph::TimeSeries;&#10;    ///&#10;    /// let series = TimeSeries::from_raw(vec![1.0, 2.0, 3.0]);&#10;    /// assert_eq!(series.len(), 3);&#10;    /// assert_eq!(series.timestamps, vec![0.0, 1.0, 2.0]);&#10;    /// ```&#10;    pub fn from_raw(values: Vec&lt;T&gt;) -&gt; Self {&#10;        let n = values.len();&#10;        let timestamps: Vec&lt;f64&gt; = (0..n).map(|i| i as f64).collect();&#10;        let values: Vec&lt;Option&lt;T&gt;&gt; = values.into_iter().map(Some).collect();&#10;        &#10;        TimeSeries { timestamps, values }&#10;    }&#10;&#10;    /// Creates a time series with explicit timestamps.&#10;    ///&#10;    /// # Arguments&#10;    ///&#10;    /// - `timestamps`: Time points for each value&#10;    /// - `values`: Data values (Some(v) for present, None for missing)&#10;    ///&#10;    /// # Errors&#10;    ///&#10;    /// Returns [`TimeSeriesError::LengthMismatch`] if timestamps and values have different lengths.&#10;    /// Returns [`TimeSeriesError::EmptyData`] if both vectors are empty.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```rust&#10;    /// use rustygraph::TimeSeries;&#10;    ///&#10;    /// let series = TimeSeries::new(&#10;    ///     vec![0.0, 1.0, 2.0],&#10;    ///     vec![Some(1.0), None, Some(3.0)]&#10;    /// ).unwrap();&#10;    /// ```&#10;    pub fn new(timestamps: Vec&lt;f64&gt;, values: Vec&lt;Option&lt;T&gt;&gt;) -&gt; Result&lt;Self, TimeSeriesError&gt; {&#10;        if timestamps.len() != values.len() {&#10;            return Err(TimeSeriesError::LengthMismatch {&#10;                timestamps: timestamps.len(),&#10;                values: values.len(),&#10;            });&#10;        }&#10;        &#10;        if timestamps.is_empty() {&#10;            return Err(TimeSeriesError::EmptyData);&#10;        }&#10;        &#10;        Ok(TimeSeries { timestamps, values })&#10;    }&#10;&#10;    /// Returns the length of the time series.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```rust&#10;    /// use rustygraph::TimeSeries;&#10;    ///&#10;    /// let series = TimeSeries::from_raw(vec![1.0, 2.0, 3.0]);&#10;    /// assert_eq!(series.len(), 3);&#10;    /// ```&#10;    pub fn len(&amp;self) -&gt; usize {&#10;        self.values.len()&#10;    }&#10;&#10;    /// Returns true if the time series contains no data points.&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```rust&#10;    /// use rustygraph::TimeSeries;&#10;    ///&#10;    /// let series = TimeSeries::from_raw(vec![1.0]);&#10;    /// assert!(!series.is_empty());&#10;    /// ```&#10;    pub fn is_empty(&amp;self) -&gt; bool {&#10;        self.values.is_empty()&#10;    }&#10;}&#10;&#10;// Placeholder for missing data handling - will be implemented in features module&#10;impl&lt;T&gt; TimeSeries&lt;T&gt; {&#10;    /// Handles missing data using the specified strategy.&#10;    ///&#10;    /// This method creates a new time series with imputed values based on the&#10;    /// chosen strategy. The original series is not modified.&#10;    ///&#10;    /// # Arguments&#10;    ///&#10;    /// - `strategy`: The imputation strategy to apply&#10;    ///&#10;    /// # Returns&#10;    ///&#10;    /// A new `TimeSeries` with imputed values&#10;    ///&#10;    /// # Errors&#10;    ///&#10;    /// Returns an error if imputation fails (e.g., insufficient data for the strategy)&#10;    ///&#10;    /// # Examples&#10;    ///&#10;    /// ```rust&#10;    /// use rustygraph::{TimeSeries, MissingDataStrategy};&#10;    ///&#10;    /// let series = TimeSeries::new(&#10;    ///     vec![0.0, 1.0, 2.0],&#10;    ///     vec![Some(1.0), None, Some(3.0)]&#10;    /// ).unwrap();&#10;    ///&#10;    /// let cleaned = series.handle_missing(&#10;    ///     MissingDataStrategy::LinearInterpolation&#10;    /// ).unwrap();&#10;    /// ```&#10;    pub fn handle_missing(&amp;self, _strategy: crate::features::missing_data::MissingDataStrategy) &#10;        -&gt; Result&lt;Self, crate::features::missing_data::ImputationError&gt; &#10;    where&#10;        T: Clone,&#10;    {&#10;        // Implementation will be provided&#10;        todo!(&quot;Missing data handling implementation&quot;)&#10;    }&#10;}&#10;&#10;/// Errors that can occur during time series operations.&#10;#[derive(Debug, Clone, PartialEq)]&#10;pub enum TimeSeriesError {&#10;    /// Timestamps and values have different lengths&#10;    LengthMismatch {&#10;        /// Number of timestamps&#10;        timestamps: usize,&#10;        /// Number of values&#10;        values: usize,&#10;    },&#10;    /// Empty time series&#10;    EmptyData,&#10;    /// Invalid timestamp order (not monotonically increasing)&#10;    NonMonotonicTimestamps,&#10;}&#10;&#10;impl fmt::Display for TimeSeriesError {&#10;    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {&#10;        match self {&#10;            TimeSeriesError::LengthMismatch { timestamps, values } =&gt; {&#10;                write!(f, &quot;Length mismatch: {} timestamps but {} values&quot;, timestamps, values)&#10;            }&#10;            TimeSeriesError::EmptyData =&gt; write!(f, &quot;Time series is empty&quot;),&#10;            TimeSeriesError::NonMonotonicTimestamps =&gt; {&#10;                write!(f, &quot;Timestamps must be monotonically increasing&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;impl std::error::Error for TimeSeriesError {}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>